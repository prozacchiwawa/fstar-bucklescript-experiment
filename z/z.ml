(* Based on Z.ml from Zarith

   This file was automatically generated by z_pp.pl from z.mlp *)  (**
   Integers.


   This file is part of the Zarith library
   http://forge.ocamlcore.org/projects/zarith .
   It is distributed under LGPL 2 licensing, with static linking exception.
   See the LICENSE file included in the distribution.

   Copyright (c) 2010-2011 Antoine Miné, Abstraction project.
   Abstraction is part of the LIENS (Laboratoire d'Informatique de l'ENS),
   a joint laboratory by:
   CNRS (Centre national de la recherche scientifique, France),
   ENS (École normale supérieure, Paris, France),
   INRIA Rocquencourt (Institut national de recherche en informatique, France).

 *)

open BigInteger

type t = BigInteger.t

exception Overflow

let i_ (x : int) : BigInteger.t = BigInteger.bigInt @@ `Int x
let of_int x = i_ x

let zero = of_int 0
let one = of_int 1
let minus_one = of_int (-1)

let neg (x : BigInteger.t) : BigInteger.t = BigInteger.times x @@ `BigInt (i_ (-1))
let add (a : BigInteger.t) (b : BigInteger.t) = BigInteger.add a (`BigInt b)
let sub (a : BigInteger.t) (b : BigInteger.t) = BigInteger.minus a (`BigInt b)
let mul (a : BigInteger.t) (b : BigInteger.t) = BigInteger.times a (`BigInt b)
let div (a : BigInteger.t) (b : BigInteger.t) = BigInteger.divide a (`BigInt b)
let rem (a : BigInteger.t) (b : BigInteger.t) : BigInteger.t =
  BigInteger.remainder a (`BigInt b)
let div_rem (a : BigInteger.t) (b : BigInteger.t) : (BigInteger.t * BigInteger.t) =
  let r = BigInteger.divmod a (`BigInt b) in
  (r.quotient, r.remainder)
let succ = BigInteger.next
let pred = BigInteger.prev
let abs (a : BigInteger.t) : BigInteger.t = BigInteger.abs a
let logand = BigInteger.and_
let logor = BigInteger.or_
let logxor = BigInteger.xor
let lognot = BigInteger.not_
let to_int s = int_of_string @@ BigInteger.toString ~base:10 s ()
let shift_left (a : BigInteger.t) (b : int) = BigInteger.shiftLeft a b
let shift_right a b =
  let s1 = of_int 1 in
  BigInteger.divide a (`BigInt (shift_left s1 b))
let shift_right_trunc = BigInteger.shiftRight
let of_int32 x = `String (Int32.to_string x)
let of_int64 x = `String (Int64.to_string x)
let of_float x =
  let (fi, _) = modf x in
  let s = String.split_on_char '.' (string_of_float fi) in
  match s with
  | [] -> i_ 0
  | "" :: _ -> i_ 0
  | hd :: _ -> BigInteger.bigInt @@ `String hd
let to_int32 s = Int32.of_string @@ BigInteger.toString ~base:10 s ()
let to_int64 s = Int64.of_string @@ BigInteger.toString ~base:10 s ()
let format _ x = toString ~base:10 x
(*
external format: string -> t -> string = "ml_z_format"
*)

(* Base *)
let of_substring_base base s ~pos:p ~len:l =
  let s = String.sub s p l in
  BigInteger.bigIntBaseN (`String s) @@ `Int base

let compare (a : BigInteger.t) (b : BigInteger.t) =
  match BigInteger.compare a (`BigInt b) with
  | EqualTo -> 0
  | LessThan -> -1
  | GreaterThan -> 1
let equal (a : BigInteger.t) (b : BigInteger.t) : bool =
  BigInteger.compare a (`BigInt b) == EqualTo
let sign (a : BigInteger.t) : int = if BigInteger.lesser a (`Int 0) then -1 else 1
let gcd (a : BigInteger.t) (b : BigInteger.t) = BigInteger.gcd (`BigInt a) (`BigInt b)

let cdiv a b =
  let s = sign a in
  let aa = abs a in
  let (d,r) = div_rem aa b in
  let addend =
    if compare r zero == 0 || s < 0 then
      zero
    else
      one
  in
  add (mul d (of_int s)) addend

let fdiv a b =
  let s = sign a in
  let aa = abs a in
  let (d,r) = div_rem aa b in
  let addend =
    if compare r zero == 0 || s > 0 then
      one
    else
      zero
  in
  sub (mul d (of_int s)) addend

let gcdext_intern (a : BigInteger.t) (b : BigInteger.t) : (BigInteger.t * BigInteger.t * bool) =
  (one, one, false)

let sqrt x = of_float (sqrt (Int64.to_float (to_int64 x)))
(*
external sqrt_rem: t -> (t * t) = "ml_z_sqrt_rem"
*)
let numbits (a : BigInteger.t) : int = to_int @@ BigInteger.bitLength a
let trailing_zeroes x =
  let rec tzr n v =
    if BigInteger.isOdd v then i_ n else tzr (n+1) (BigInteger.shiftLeft v 1)
  in
  tzr 0 x

let pow (v : BigInteger.t) (e : int) : BigInteger.t = BigInteger.pow v (`Int e)

let divexact (a : BigInteger.t) (b : BigInteger.t) : BigInteger.t =
  BigInteger.divide a (`BigInt b)

let extract (a : BigInteger.t) (off : int) (len : int) : (BigInteger.t) =
  let from_val = shift_right a off in
  let modulus = shift_left one len in
  rem from_val modulus

(*
external popcount: t -> int = "ml_z_popcount"
external hamdist: t -> t -> int = "ml_z_hamdist"
external size: t -> int = "ml_z_size" [@@noalloc]
external fits_int: t -> bool = "ml_z_fits_int" [@@noalloc]
external fits_int32: t -> bool = "ml_z_fits_int32" [@@noalloc]
external fits_int64: t -> bool = "ml_z_fits_int64" [@@noalloc]
external fits_nativeint: t -> bool = "ml_z_fits_nativeint" [@@noalloc]
external powm: t -> t -> t -> t = "ml_z_powm"
external powm_sec: t -> t -> t -> t = "ml_z_powm_sec"
external root: t -> int -> t = "ml_z_root"
external rootrem: t -> int -> t * t = "ml_z_rootrem"
external invert: t -> t -> t = "ml_z_invert"
external perfect_power: t -> bool = "ml_z_perfect_power"
external perfect_square: t -> bool = "ml_z_perfect_square"
external probab_prime: t -> int -> int = "ml_z_probab_prime"
external nextprime: t -> t = "ml_z_nextprime"
external hash: t -> int = "ml_z_hash" [@@noalloc]
external to_bits: t -> string = "ml_z_to_bits"
external of_bits: string -> t = "ml_z_of_bits"
external divisible: t -> t -> bool = "ml_z_divisible"
external congruent: t -> t -> t -> bool = "ml_z_congruent"
external jacobi: t -> t -> int = "ml_z_jacobi"
external legendre: t -> t -> int = "ml_z_legendre"
external kronecker: t -> t -> int = "ml_z_kronecker"
external remove: t -> t -> t * int = "ml_z_remove"
external fac: int -> t = "ml_z_fac"
external fac2: int -> t = "ml_z_fac2"
external facM: int -> int -> t = "ml_z_facM"
external primorial: int -> t = "ml_z_primorial"
external bin: t -> int -> t = "ml_z_bin"
external fib: int -> t = "ml_z_fib"
external lucnum: int -> t = "ml_z_lucnum"
*)

let min (a : BigInteger.t) (b : BigInteger.t) : BigInteger.t =
  if compare a b <= 0 then a else b
let max (a : BigInteger.t) (b : BigInteger.t) : BigInteger.t =
  if compare a b >= 0 then a else b

let leq a b = compare a b <= 0
let geq a b = compare a b >= 0
let lt a b = compare a b < 0
let gt a b = compare a b > 0

let to_string (x : BigInteger.t) = format "%d" x ()

let of_string s = of_substring_base 10 s ~pos:0 ~len:(String.length s)
let of_substring s pos len = of_substring_base 10 s ~pos:0 ~len:len
let of_string_base base s = of_substring_base base s ~pos:0 ~len:(String.length s)

let ediv_rem (a : BigInteger.t) (b : BigInteger.t) : (BigInteger.t * BigInteger.t) =
  (* we have a = q * b + r, but [Big_int]'s remainder satisfies 0 <= r < |b|,
     while [Z]'s remainder satisfies -|b| < r < |b| and sign(r) = sign(a)
   *)
   let q,r = div_rem a b in
   if sign r >= 0 then (q,r) else
   if sign b >= 0 then (pred q, add r b)
   else (succ q, sub r b)

let ediv a b =
   if sign b >= 0 then fdiv a b else cdiv a b

let erem a b =
   let r = rem a b in
   if sign r >= 0 then r else add r (abs b)

let gcdext u v =
  match sign u, sign v with
  (* special cases: one argument is null *)
  |  0,  0 -> zero, zero, zero
  |  0,  1 -> v, zero, one
  |  0, -1 -> neg v, zero, minus_one
  |  1,  0 -> u, one, zero
  | -1,  0 -> neg u, minus_one, zero
  | _ ->
     (* general case *)
     let g,s,z = gcdext_intern u v in
     if z then g, s, div (sub g (mul u s)) v
     else g, div (sub g (mul v s)) u, s

let lcm u v =
  if u = zero || v = zero then zero
  else
    let g = gcd u v in
    abs (mul (divexact u g) v)

external testbit_internal: t -> int -> bool = "ml_z_testbit" [@@noalloc]
let testbit x n =
  if n >= 0 then testbit_internal x n else invalid_arg "Z.testbit"
(* The test [n >= 0] is done in Caml rather than in the C stub code
   so that the latter raises no exceptions and can be declared "noalloc". *)

let is_odd x = testbit_internal x 0
let is_even x  = not (testbit_internal x 0)

let signed_extract x o l =
  if o < 0 then invalid_arg "Z.signed_extract: negative bit offset";
  if l < 1 then invalid_arg "Z.signed_extract: nonpositive bit length";
  if testbit x (o + l - 1)
  then lognot (extract (lognot x) o l)
  else extract x o l

let log2 x =
  if sign x > 0 then (numbits x) - 1 else invalid_arg "Z.log2"
let log2up x =
  if sign x > 0 then numbits (pred x) else invalid_arg "Z.log2up"

(* Consider a real number [r] such that
   - the integral part of [r] is the bigint [x]
   - 2^54 <= |x| < 2^63
   - the fractional part of [r] is 0 if [exact = true],
     nonzero if [exact = false].
   Then, the following function returns [r] correctly rounded
   according to the current rounding mode of the processor.
   This is an instance of the "round to odd" technique formalized in
   "When double rounding is odd" by S. Boldo and G. Melquiond.
   The claim above is lemma Fappli_IEEE_extra.round_odd_fix
   from the CompCert Coq development. *)

let round_to_float x exact =
  let m = to_int64 x in
  (* Unless the fractional part is exactly 0, round m to an odd integer *)
  let m = if exact then m else Int64.logor m 1L in
  (* Then convert m to float, with the current rounding mode. *)
  Int64.to_float m

let to_float x =
  if Obj.is_int (Obj.repr x) then
    (* Fast path *)
    float_of_int (Obj.magic x : int)
  else begin
    let n = numbits x in
    if n <= 63 then
      Int64.to_float (to_int64 x)
    else begin
      let n = n - 55 in
      (* Extract top 55 bits of x *)
      let top = shift_right x n in
      (* Check if the other bits are all zero *)
      let exact = equal x (shift_left top n) in
      (* Round to float and apply exponent *)
      ldexp (round_to_float top exact) n
    end
  end

let print x = print_string (to_string x)
let output chan x = output_string chan (to_string x)
let sprint () x = to_string x
let bprint b x = Buffer.add_string b (to_string x)
let pp_print f x = Format.pp_print_string f (to_string x)

let (~-) = neg
let (~+) x = x
let (x) = add
let (-) = sub
let ( * ) = mul
let (/) = div
let (/>) = cdiv
let (/<) = fdiv
let (mod) = rem
let (land) = logand
let (lor) = logor
let (lxor) = logxor
let (~!) = lognot
let (lsl) = shift_left
let (asr) = shift_right
let (~$) = of_int
let ( ** ) = pow
let (/|) = divexact

module Compare = struct
  let (=) = equal
  let (<) = lt
  let (>) = gt
  let (<=) = leq
  let (>=) = geq
  let (<>) a b = not (equal a b)
end

let version = "1.11"

(*
type t = int
let to_int a = a
let of_int a = a
let to_int64 = Int64.of_int
let of_int64 = Int64.to_int
let add a b = a + b
let sub a b = a - b
let mul a b = a * b
let div a b = a / b
let ediv a b = a / b
let erem a b = a mod b
let abs a = if a < 0 then a * (-1) else a
let zero = 0
let one = 1
let gt a b = a > b
let lt a b = a < b
let leq a b = a <= b
let geq a b = a >= b
let neg a = a * -1
let of_string = int_of_string
let to_string = string_of_int
*)
